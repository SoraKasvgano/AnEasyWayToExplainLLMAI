<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIå¤§æ¨¡å‹åŸç†3Dæ¼”ç¤º - åµŒå…¥å±‚â†’Transformerâ†’è¾“å‡ºå±‚</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
            color: white;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* é¡¶éƒ¨æ ‡é¢˜æ  */
        .top-bar {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 100;
            padding-left: 200px; /* ä¸ºæ ‡ç­¾åˆ‡æ¢å™¨ç•™ç©ºé—´ */
            transition: padding-left 0.3s ease;
        }

        /* ç‹¬ç«‹é¡µé¢æ—¶ä¸éœ€è¦å·¦è¾¹è· */
        body.standalone .top-bar {
            padding-left: 0;
        }

        .title {
            font-size: 1.6rem;
            font-weight: 700;
            background: linear-gradient(135deg, #007AFF, #34C759);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .btn {
            background: rgba(0, 122, 255, 0.9);
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #007AFF;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 122, 255, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* æ­¥éª¤æŒ‡ç¤ºå™¨ */
        .step-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 100;
            background: rgba(20, 20, 40, 0.9);
            backdrop-filter: blur(20px);
            padding: 12px 25px;
            border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .step-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.4s ease;
            opacity: 0.4;
        }

        .step-item.active {
            opacity: 1;
            background: rgba(255,255,255,0.1);
        }

        .step-item.completed {
            opacity: 0.7;
        }

        .step-num {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .step-item:nth-child(1) .step-num { background: #007AFF; }
        .step-item:nth-child(3) .step-num { background: #FF9500; }
        .step-item:nth-child(5) .step-num { background: #34C759; }

        .step-name {
            font-size: 1rem;
            font-weight: 500;
        }

        .step-arrow {
            color: rgba(255,255,255,0.3);
            font-size: 1.2rem;
        }

        /* å·¦ä¾§è¯´æ˜é¢æ¿ */
        .info-panel {
            position: absolute;
            left: 20px;
            top: 150px;
            background: rgba(20, 20, 40, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 20px;
            width: 320px;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .panel-title {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title-icon {
            font-size: 1.5rem;
        }

        .explanation {
            font-size: 1rem;
            line-height: 1.7;
            color: #ccc;
            margin-bottom: 15px;
        }

        .highlight {
            color: #34C759;
            font-weight: 600;
        }

        .highlight-blue {
            color: #007AFF;
            font-weight: 600;
        }

        .highlight-orange {
            color: #FF9500;
            font-weight: 600;
        }

        .formula-box {
            background: rgba(0, 122, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            font-family: 'SF Mono', monospace;
            font-size: 0.95rem;
            color: #34C759;
            margin: 10px 0;
            text-align: center;
        }

        .current-status {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 12px;
            margin-top: 15px;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .status-row:last-child {
            margin-bottom: 0;
        }

        .status-label {
            color: #888;
            font-size: 0.9rem;
        }

        .status-value {
            font-weight: 600;
            font-size: 1rem;
        }

        /* å³ä¾§å€™é€‰é¢æ¿ */
        .candidates-panel {
            position: absolute;
            right: 20px;
            top: 150px;
            background: rgba(20, 20, 40, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 20px;
            width: 280px;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .candidate-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 10px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.03);
        }

        .candidate-item.winner {
            background: rgba(52, 199, 89, 0.2);
            border: 2px solid #34C759;
        }

        .candidate-item.searching {
            background: rgba(255, 149, 0, 0.15);
            border: 1px solid rgba(255, 149, 0, 0.5);
        }

        .candidate-char {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            font-weight: 700;
            background: rgba(255, 149, 0, 0.2);
        }

        .candidate-char.winner {
            background: rgba(52, 199, 89, 0.3);
        }

        .candidate-info {
            flex: 1;
        }

        .candidate-prob {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .candidate-dist {
            font-size: 0.85rem;
            color: #888;
        }

        /* åº•éƒ¨è¿›åº¦æ¡ */
        .bottom-bar {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            z-index: 100;
        }

        .output-display {
            background: rgba(20, 20, 40, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 15px 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .output-label {
            color: #888;
            font-size: 1rem;
        }

        .output-chars {
            display: flex;
            gap: 8px;
        }

        .output-char {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 700;
            transition: all 0.4s ease;
        }

        .output-char.input {
            background: rgba(0, 122, 255, 0.3);
            border: 2px solid #007AFF;
        }

        .output-char.generated {
            background: rgba(52, 199, 89, 0.3);
            border: 2px solid #34C759;
        }

        .output-char.predicting {
            background: rgba(255, 149, 0, 0.3);
            border: 2px solid #FF9500;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* å›¾ä¾‹ */
        .legend {
            position: absolute;
            bottom: 25px;
            left: 20px;
            background: rgba(20, 20, 40, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 16px;
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        .legend-dot.input { background: #007AFF; }
        .legend-dot.output { background: #34C759; }
        .legend-dot.candidate { background: #FF9500; }
        .legend-dot.query { background: #FF3B30; }
        .legend-dot.attention { background: #AF52DE; }

        /* æç¤º */
        .hint {
            position: absolute;
            bottom: 25px;
            right: 20px;
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 0.85rem;
            color: #888;
            z-index: 100;
        }

        /* éšè—æ»šåŠ¨æ¡ */
        .info-panel::-webkit-scrollbar {
            width: 4px;
        }
        .info-panel::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- é¡¶éƒ¨æ§åˆ¶æ  -->
    <div class="top-bar">
        <div class="title">AIå¤§æ¨¡å‹åŸç† 3D å¯è§†åŒ–</div>
        <button class="btn" id="startBtn" onclick="startDemo()">å¼€å§‹æ¼”ç¤º</button>
        <button class="btn" onclick="resetCamera()" style="background: rgba(100,100,120,0.8);">é‡ç½®è§†è§’</button>
    </div>

    <!-- æ­¥éª¤æŒ‡ç¤ºå™¨ -->
    <div class="step-indicator">
        <div class="step-item" id="step1">
            <div class="step-num">1</div>
            <div class="step-name">åµŒå…¥å±‚</div>
        </div>
        <div class="step-arrow">â†’</div>
        <div class="step-item" id="step2">
            <div class="step-num">2</div>
            <div class="step-name">Transformer</div>
        </div>
        <div class="step-arrow">â†’</div>
        <div class="step-item" id="step3">
            <div class="step-num">3</div>
            <div class="step-name">è¾“å‡ºå±‚</div>
        </div>
    </div>

    <!-- å·¦ä¾§è¯´æ˜é¢æ¿ -->
    <div class="info-panel" id="infoPanel">
        <div class="panel-title">
            <span class="panel-title-icon">ğŸ“–</span>
            <span id="panelTitleText">ç‚¹å‡»å¼€å§‹æ¼”ç¤º</span>
        </div>
        <div class="explanation" id="explanationText">
            æœ¬æ¼”ç¤ºå°†å±•ç¤ºAIå¤§è¯­è¨€æ¨¡å‹å¦‚ä½•ä¸€æ­¥æ­¥ç”Ÿæˆå›ç­”ã€‚
            <br><br>
            è¾“å…¥ï¼š<span class="highlight-blue">"å¤©ç‹ç›–åœ°è™"</span>
            <br>
            AIå°†é€å­—ç”Ÿæˆï¼š<span class="highlight">"å®å¡”é•‡æ²³å¦–"</span>
            <br><br>
            ç‚¹å‡»"å¼€å§‹æ¼”ç¤º"è§‚çœ‹å®Œæ•´è¿‡ç¨‹ï¼
        </div>
        <div class="current-status" id="currentStatus" style="display:none;">
            <div class="status-row">
                <span class="status-label">å½“å‰è¾“å…¥</span>
                <span class="status-value" id="statusInput">å¤©ç‹ç›–åœ°è™</span>
            </div>
            <div class="status-row">
                <span class="status-label">å·²ç”Ÿæˆ</span>
                <span class="status-value" id="statusOutput" style="color:#34C759;">-</span>
            </div>
            <div class="status-row">
                <span class="status-label">æ­£åœ¨é¢„æµ‹</span>
                <span class="status-value" id="statusPredicting" style="color:#FF9500;">?</span>
            </div>
        </div>
    </div>

    <!-- å³ä¾§å€™é€‰é¢æ¿ -->
    <div class="candidates-panel" id="candidatesPanel" style="display:none;">
        <div class="panel-title">
            <span class="panel-title-icon">ğŸ¯</span>
            <span>å€™é€‰å­—æ¦‚ç‡</span>
        </div>
        <div id="candidatesList"></div>
    </div>

    <!-- åº•éƒ¨è¾“å‡ºå±•ç¤º -->
    <div class="bottom-bar">
        <div class="output-display">
            <div class="output-label">åºåˆ—ï¼š</div>
            <div class="output-chars" id="outputChars">
                <div class="output-char input">å¤©</div>
                <div class="output-char input">ç‹</div>
                <div class="output-char input">ç›–</div>
                <div class="output-char input">åœ°</div>
                <div class="output-char input">è™</div>
            </div>
        </div>
    </div>

    <!-- å›¾ä¾‹ -->
    <div class="legend">
        <div class="legend-item">
            <div class="legend-dot input"></div>
            <span>è¾“å…¥å­—ç¬¦</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot output"></div>
            <span>å·²ç”Ÿæˆå­—ç¬¦</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot candidate"></div>
            <span>å€™é€‰å­—ç¬¦</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot attention"></div>
            <span>æ³¨æ„åŠ›è¿çº¿</span>
        </div>
    </div>

    <!-- æç¤º -->
    <div class="hint">ğŸ–±ï¸ æ‹–åŠ¨æ—‹è½¬ | æ»šè½®ç¼©æ”¾</div>

    <script src="./three.min.js"></script>

    <script>
        // æ£€æµ‹æ˜¯å¦ç‹¬ç«‹è¿è¡Œï¼ˆä¸åœ¨iframeä¸­ï¼‰
        if (window.self === window.top) {
            document.body.classList.add('standalone');
        }

        // ============ å…¨å±€å˜é‡ ============
        let scene, camera, renderer;
        let charMeshes = {};
        let candidateMeshes = [];
        let attentionLines = [];
        let queryMesh = null;
        let searchBeam = null;
        let isRunning = false;

        const inputText = "å¤©ç‹ç›–åœ°è™";
        const outputText = "å®å¡”é•‡æ²³å¦–";

        // 3Dä½ç½®ï¼ˆæ¨¡æ‹ŸåµŒå…¥å‘é‡é™ç»´åˆ°3Dï¼‰
        const embedPositions = {
            'å¤©': { pos: new THREE.Vector3(-4, 2, 0), color: 0x007AFF },
            'ç‹': { pos: new THREE.Vector3(-2, 2.5, 1), color: 0x007AFF },
            'ç›–': { pos: new THREE.Vector3(0, 2, 2), color: 0x007AFF },
            'åœ°': { pos: new THREE.Vector3(2, 2.5, 1), color: 0x007AFF },
            'è™': { pos: new THREE.Vector3(4, 2, 0), color: 0x007AFF },
            // è¾“å‡ºå­—ç¬¦
            'å®': { pos: new THREE.Vector3(-4, -2, -1), color: 0x34C759 },
            'å¡”': { pos: new THREE.Vector3(-2, -2.5, -2), color: 0x34C759 },
            'é•‡': { pos: new THREE.Vector3(0, -2, -1), color: 0x34C759 },
            'æ²³': { pos: new THREE.Vector3(2, -2.5, -2), color: 0x34C759 },
            'å¦–': { pos: new THREE.Vector3(4, -2, -1), color: 0x34C759 }
        };

        // é¢„æµ‹æ•°æ®
        const predictionData = {
            'å®': {
                attention: { 'å¤©': 0.25, 'ç‹': 0.18, 'ç›–': 0.12, 'åœ°': 0.15, 'è™': 0.30 },
                candidates: [
                    { char: 'å®', prob: 0.72, vec: new THREE.Vector3(-4, -2, -1) },
                    { char: 'é‡‘', prob: 0.12, vec: new THREE.Vector3(-3.5, -1.5, 0) },
                    { char: 'é“¶', prob: 0.08, vec: new THREE.Vector3(-4.5, -1, 0.5) },
                    { char: 'ç‰', prob: 0.05, vec: new THREE.Vector3(-3, -2.5, 0) },
                    { char: 'ç ', prob: 0.03, vec: new THREE.Vector3(-4, -1, 1) }
                ],
                insight: 'æ¨¡å‹ä»è®­ç»ƒæ•°æ®ä¸­å­¦åˆ°"å¤©ç‹ç›–åœ°è™"åé¢é€šå¸¸è·Ÿ"å®å¡”é•‡æ²³å¦–"ï¼Œ"å®"å­—æ¦‚ç‡æœ€é«˜ã€‚'
            },
            'å¡”': {
                attention: { 'å¤©': 0.15, 'ç‹': 0.22, 'ç›–': 0.10, 'åœ°': 0.12, 'è™': 0.16, 'å®': 0.25 },
                candidates: [
                    { char: 'å¡”', prob: 0.78, vec: new THREE.Vector3(-2, -2.5, -2) },
                    { char: 'æ®¿', prob: 0.10, vec: new THREE.Vector3(-1.5, -2, -1) },
                    { char: 'æ¥¼', prob: 0.06, vec: new THREE.Vector3(-2.5, -1.5, -1) },
                    { char: 'é˜', prob: 0.04, vec: new THREE.Vector3(-1, -2.5, -1.5) },
                    { char: 'å±±', prob: 0.02, vec: new THREE.Vector3(-2, -3, -0.5) }
                ],
                insight: 'æ³¨æ„åŠ›é›†ä¸­åœ¨"å®"å’Œ"ç‹"ä¸Šï¼Œ"å®å¡”"æ˜¯å¸¸è§è¯ç»„æ­é…ï¼Œä¸"å¤©ç‹"å½¢æˆå¯¹ä»—ã€‚'
            },
            'é•‡': {
                attention: { 'å¤©': 0.10, 'ç‹': 0.12, 'ç›–': 0.28, 'åœ°': 0.15, 'è™': 0.10, 'å®': 0.12, 'å¡”': 0.13 },
                candidates: [
                    { char: 'é•‡', prob: 0.75, vec: new THREE.Vector3(0, -2, -1) },
                    { char: 'å‹', prob: 0.12, vec: new THREE.Vector3(0.5, -1.5, 0) },
                    { char: 'å®ˆ', prob: 0.07, vec: new THREE.Vector3(-0.5, -2.5, 0) },
                    { char: 'æŠ¤', prob: 0.04, vec: new THREE.Vector3(0, -1, -0.5) },
                    { char: 'å°', prob: 0.02, vec: new THREE.Vector3(0.5, -2.5, -0.5) }
                ],
                insight: 'é‡ç‚¹å…³æ³¨åŠ¨è¯"ç›–"ï¼Œéœ€è¦æ‰¾å¯¹åº”çš„åŠ¨ä½œè¯ã€‚"é•‡"ä¸"ç›–"éƒ½æ˜¯åŠ¨è¯ï¼Œå½¢æˆå¯¹ä»—ã€‚'
            },
            'æ²³': {
                attention: { 'å¤©': 0.08, 'ç‹': 0.10, 'ç›–': 0.12, 'åœ°': 0.32, 'è™': 0.10, 'å®': 0.08, 'å¡”': 0.08, 'é•‡': 0.12 },
                candidates: [
                    { char: 'æ²³', prob: 0.70, vec: new THREE.Vector3(2, -2.5, -2) },
                    { char: 'æ±Ÿ', prob: 0.14, vec: new THREE.Vector3(2.5, -2, -1) },
                    { char: 'æµ·', prob: 0.08, vec: new THREE.Vector3(1.5, -2, -1.5) },
                    { char: 'æ¹–', prob: 0.05, vec: new THREE.Vector3(2, -1.5, -1) },
                    { char: 'å±±', prob: 0.03, vec: new THREE.Vector3(2.5, -3, -1) }
                ],
                insight: 'å¼ºçƒˆå…³æ³¨"åœ°"å­—ï¼Œå¯»æ‰¾ä¸"åœ°"å¯¹åº”çš„åœ°ç†åè¯ã€‚"æ²³"ä¸"åœ°"è¯­ä¹‰ç›¸å…³ï¼Œéƒ½æŒ‡è‡ªç„¶ç¯å¢ƒã€‚'
            },
            'å¦–': {
                attention: { 'å¤©': 0.08, 'ç‹': 0.10, 'ç›–': 0.10, 'åœ°': 0.12, 'è™': 0.35, 'å®': 0.05, 'å¡”': 0.06, 'é•‡': 0.06, 'æ²³': 0.08 },
                candidates: [
                    { char: 'å¦–', prob: 0.82, vec: new THREE.Vector3(4, -2, -1) },
                    { char: 'é­”', prob: 0.08, vec: new THREE.Vector3(4.5, -1.5, 0) },
                    { char: 'æ€ª', prob: 0.05, vec: new THREE.Vector3(3.5, -2.5, 0) },
                    { char: 'é¬¼', prob: 0.03, vec: new THREE.Vector3(4, -1, 0.5) },
                    { char: 'å…½', prob: 0.02, vec: new THREE.Vector3(3.5, -1.5, -0.5) }
                ],
                insight: 'æœ€å…³æ³¨"è™"ï¼"è™"å’Œ"å¦–"éƒ½æ˜¯åŠ¨ç‰©/ç”Ÿç‰©ç±»è¯ï¼Œä¸”æŠ¼éŸµï¼ˆhu-yaoï¼‰ï¼Œå®Œç¾å¯¹ä»—ï¼'
            }
        };

        // ============ åˆå§‹åŒ–åœºæ™¯ ============
        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 16);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0a0a1a, 1);
            container.appendChild(renderer.domElement);

            // å…‰ç…§
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0x007AFF, 1, 50);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x34C759, 0.8, 50);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);

            // æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯
            createStarField();

            // æ·»åŠ ç½‘æ ¼å‚è€ƒå¹³é¢
            createReferenceGrid();

            // é¼ æ ‡æ§åˆ¶
            setupControls();

            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createStarField() {
            const starsGeometry = new THREE.BufferGeometry();
            const starCount = 500;
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = (Math.random() - 0.5) * 100;
                positions[i + 2] = (Math.random() - 0.5) * 100 - 20;
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.6 });
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        function createReferenceGrid() {
            // æ·¡åŒ–ç½‘æ ¼
            const gridHelper = new THREE.GridHelper(20, 20, 0x222244, 0x111133);
            gridHelper.position.y = -4;
            scene.add(gridHelper);

            // æ·»åŠ åˆ†éš”å¹³é¢æ ‡ç­¾
            addLabel('è¾“å…¥å±‚ (Embedding)', new THREE.Vector3(0, 3.5, 0), 0x007AFF);
            addLabel('è¾“å‡ºå±‚ (Prediction)', new THREE.Vector3(0, -3.5, 0), 0x34C759);
        }

        function addLabel(text, position, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = `rgba(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255}, 0.8)`;
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 256, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(6, 0.8, 1);
            scene.add(sprite);
        }

        // ============ åˆ›å»ºå­—ç¬¦çƒä½“ ============
        function createCharSphere(char, position, color, scale = 1) {
            const group = new THREE.Group();

            // çƒä½“
            const geometry = new THREE.SphereGeometry(0.4 * scale, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);

            // å¤–åœˆå…‰æ™•
            const glowGeometry = new THREE.SphereGeometry(0.5 * scale, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.15
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);

            // æ–‡å­—æ ‡ç­¾
            const label = createTextLabel(char, color);
            label.position.y = 0.7 * scale;
            group.add(label);

            group.position.copy(position);
            scene.add(group);

            return { group, sphere, glow, label };
        }

        function createTextLabel(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'white';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1, 1, 1);

            return sprite;
        }

        // ============ æ³¨æ„åŠ›è¿çº¿ ============
        function createAttentionLine(from, to, weight, color = 0xAF52DE) {
            const points = [from.clone(), to.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: Math.min(weight * 2, 0.9),
                linewidth: 2
            });

            const line = new THREE.Line(geometry, material);
            scene.add(line);

            return line;
        }

        // åˆ›å»ºæ›²çº¿æ³¨æ„åŠ›çº¿ï¼ˆæ›´ç¾è§‚ï¼‰
        function createCurvedAttentionLine(from, to, weight, color = 0xAF52DE) {
            const mid = new THREE.Vector3().addVectors(from, to).multiplyScalar(0.5);
            mid.y += 1.5; // å¼§åº¦

            const curve = new THREE.QuadraticBezierCurve3(from, mid, to);
            const points = curve.getPoints(30);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: Math.min(weight * 2.5, 0.95),
                linewidth: 2
            });

            const line = new THREE.Line(geometry, material);
            scene.add(line);

            // æ·»åŠ æµåŠ¨ç²’å­æ•ˆæœ
            const particleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particle.userData.curve = curve;
            particle.userData.progress = 0;
            scene.add(particle);

            return { line, particle };
        }

        // ============ é¼ æ ‡æ§åˆ¶ ============
        function setupControls() {
            let isDragging = false;
            let prevMouse = { x: 0, y: 0 };
            let spherical = { theta: 0, phi: Math.PI / 2.5, radius: 16 };

            function updateCamera() {
                camera.position.x = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
                camera.position.y = spherical.radius * Math.cos(spherical.phi);
                camera.position.z = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
                camera.lookAt(0, 0, 0);
            }

            renderer.domElement.addEventListener('mousedown', e => {
                isDragging = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', e => {
                if (!isDragging) return;
                const dx = e.clientX - prevMouse.x;
                const dy = e.clientY - prevMouse.y;
                spherical.theta -= dx * 0.01;
                spherical.phi = Math.max(0.3, Math.min(Math.PI - 0.3, spherical.phi + dy * 0.01));
                updateCamera();
                prevMouse = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

            renderer.domElement.addEventListener('wheel', e => {
                spherical.radius = Math.max(8, Math.min(30, spherical.radius + e.deltaY * 0.02));
                updateCamera();
            });

            window.resetCamera = () => {
                spherical = { theta: 0, phi: Math.PI / 2.5, radius: 16 };
                updateCamera();
            };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ åŠ¨ç”»å¾ªç¯ ============
        let animationObjects = [];

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // è®©çƒä½“è½»å¾®æµ®åŠ¨
            Object.values(charMeshes).forEach((mesh, i) => {
                if (mesh && mesh.group) {
                    mesh.group.position.y = mesh.originalY + Math.sin(time * 1.5 + i * 0.5) * 0.1;
                }
            });

            // æ›´æ–°æ³¨æ„åŠ›ç²’å­åŠ¨ç”»
            animationObjects.forEach(obj => {
                if (obj.particle && obj.particle.userData.curve) {
                    obj.particle.userData.progress += 0.015;
                    if (obj.particle.userData.progress > 1) obj.particle.userData.progress = 0;
                    const point = obj.particle.userData.curve.getPoint(obj.particle.userData.progress);
                    obj.particle.position.copy(point);
                }
            });

            renderer.render(scene, camera);
        }

        // ============ å·¥å…·å‡½æ•° ============
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function setStepActive(stepNum) {
            document.querySelectorAll('.step-item').forEach((el, i) => {
                el.classList.remove('active', 'completed');
                if (i + 1 < stepNum) el.classList.add('completed');
                if (i + 1 === stepNum) el.classList.add('active');
            });
        }

        function clearScene() {
            // æ¸…é™¤å­—ç¬¦çƒä½“
            Object.values(charMeshes).forEach(mesh => {
                if (mesh && mesh.group) scene.remove(mesh.group);
            });
            charMeshes = {};

            // æ¸…é™¤å€™é€‰çƒä½“
            candidateMeshes.forEach(mesh => {
                if (mesh && mesh.group) scene.remove(mesh.group);
            });
            candidateMeshes = [];

            // æ¸…é™¤æ³¨æ„åŠ›çº¿
            attentionLines.forEach(obj => {
                if (obj.line) scene.remove(obj.line);
                if (obj.particle) scene.remove(obj.particle);
            });
            attentionLines = [];
            animationObjects = [];

            // æ¸…é™¤æŸ¥è¯¢çƒ
            if (queryMesh) {
                scene.remove(queryMesh.group);
                queryMesh = null;
            }
        }

        function updateOutputDisplay(generatedChars) {
            const container = document.getElementById('outputChars');
            container.innerHTML = '';

            // è¾“å…¥å­—ç¬¦
            for (const char of inputText) {
                const div = document.createElement('div');
                div.className = 'output-char input';
                div.textContent = char;
                container.appendChild(div);
            }

            // å·²ç”Ÿæˆå­—ç¬¦
            for (const char of generatedChars) {
                const div = document.createElement('div');
                div.className = 'output-char generated';
                div.textContent = char;
                container.appendChild(div);
            }

            // æ­£åœ¨é¢„æµ‹
            if (generatedChars.length < outputText.length) {
                const div = document.createElement('div');
                div.className = 'output-char predicting';
                div.textContent = '?';
                container.appendChild(div);
            }
        }

        // ============ ä¸»æ¼”ç¤ºæµç¨‹ ============
        async function startDemo() {
            if (isRunning) return;
            isRunning = true;

            const btn = document.getElementById('startBtn');
            btn.disabled = true;
            btn.textContent = 'æ¼”ç¤ºä¸­...';

            document.getElementById('currentStatus').style.display = 'block';
            document.getElementById('candidatesPanel').style.display = 'none';

            clearScene();

            let generatedText = '';

            for (let round = 0; round < outputText.length; round++) {
                const targetChar = outputText[round];
                const currentInput = inputText + generatedText;

                document.getElementById('statusInput').textContent = currentInput;
                document.getElementById('statusOutput').textContent = generatedText || '-';
                document.getElementById('statusPredicting').textContent = '?';
                updateOutputDisplay(generatedText);

                // ========== Step 1: åµŒå…¥å±‚ ==========
                setStepActive(1);
                await showEmbeddingStep(currentInput, round);

                // ========== Step 2: Transformer ==========
                setStepActive(2);
                await showTransformerStep(targetChar, currentInput);

                // ========== Step 3: è¾“å‡ºå±‚ ==========
                setStepActive(3);
                const selected = await showOutputStep(targetChar);

                // æ›´æ–°ç”Ÿæˆç»“æœ
                generatedText += selected;
                document.getElementById('statusOutput').textContent = generatedText;
                document.getElementById('statusPredicting').textContent = selected;
                updateOutputDisplay(generatedText);

                // å°†é€‰ä¸­å­—ç¬¦åŠ å…¥åœºæ™¯
                const charData = embedPositions[selected];
                if (charData && !charMeshes[selected]) {
                    charMeshes[selected] = createCharSphere(selected, charData.pos, 0x34C759);
                    charMeshes[selected].originalY = charData.pos.y;
                }

                await sleep(800);

                // æ¸…é™¤æ³¨æ„åŠ›çº¿å’Œå€™é€‰
                clearAttentionAndCandidates();
            }

            // å®Œæˆ
            setStepActive(0);
            document.getElementById('panelTitleText').textContent = 'ğŸ‰ ç”Ÿæˆå®Œæˆï¼';
            document.getElementById('explanationText').innerHTML = `
                AIæˆåŠŸç”Ÿæˆäº†å®Œæ•´å›ç­”ï¼š<br><br>
                <span class="highlight-blue">"å¤©ç‹ç›–åœ°è™"</span> â†’ <span class="highlight">"å®å¡”é•‡æ²³å¦–"</span>
                <br><br>
                æ•´ä¸ªè¿‡ç¨‹å±•ç¤ºäº†ï¼š<br>
                1. <span class="highlight-blue">åµŒå…¥å±‚</span>ï¼šå°†æ–‡å­—è½¬æ¢ä¸ºå‘é‡<br>
                2. <span class="highlight-orange">Transformer</span>ï¼šé€šè¿‡æ³¨æ„åŠ›æœºåˆ¶ç†è§£ä¸Šä¸‹æ–‡<br>
                3. <span class="highlight">è¾“å‡ºå±‚</span>ï¼šè®¡ç®—æ¦‚ç‡ï¼Œé€‰æ‹©ä¸‹ä¸€ä¸ªå­—
            `;

            btn.disabled = false;
            btn.textContent = 'é‡æ–°æ¼”ç¤º';
            isRunning = false;
        }

        // Step 1: åµŒå…¥å±‚
        async function showEmbeddingStep(text, round) {
            document.getElementById('panelTitleText').textContent = 'ğŸ“¥ åµŒå…¥å±‚ (Embedding)';
            document.getElementById('explanationText').innerHTML = `
                <span class="highlight-blue">ç¬¬ä¸€æ­¥ï¼šå°†æ–‡å­—è½¬æ¢ä¸ºå‘é‡</span>
                <br><br>
                æ¯ä¸ªå­—ç¬¦è¢«è½¬æ¢æˆä¸€ä¸ª<span class="highlight">é«˜ç»´å‘é‡</span>ï¼ˆé€šå¸¸768-4096ç»´ï¼‰ã€‚
                <br><br>
                è¿™é‡Œç”¨3Dç©ºé—´ç®€åŒ–å±•ç¤ºï¼š<br>
                â€¢ è¯­ä¹‰ç›¸è¿‘çš„å­—ï¼Œå‘é‡ä½ç½®ç›¸è¿‘<br>
                â€¢ æ¯ä¸ªä½ç½®è¿˜ä¼šåŠ å…¥<span class="highlight-orange">ä½ç½®ç¼–ç </span>
                <div class="formula-box">
                    E(å­—ç¬¦) = è¯­ä¹‰å‘é‡ + ä½ç½®ç¼–ç 
                </div>
            `;

            // åªåœ¨ç¬¬ä¸€è½®åˆ›å»ºè¾“å…¥å­—ç¬¦
            if (round === 0) {
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    const data = embedPositions[char];
                    if (data && !charMeshes[char]) {
                        await sleep(200);
                        charMeshes[char] = createCharSphere(char, data.pos, data.color);
                        charMeshes[char].originalY = data.pos.y;
                    }
                }
            }

            await sleep(1000);
        }

        // Step 2: Transformer
        async function showTransformerStep(targetChar, currentInput) {
            const data = predictionData[targetChar];

            document.getElementById('panelTitleText').textContent = 'ğŸ§  Transformerå±‚';
            document.getElementById('explanationText').innerHTML = `
                <span class="highlight-orange">ç¬¬äºŒæ­¥ï¼šæ³¨æ„åŠ›æœºåˆ¶åˆ†æä¸Šä¸‹æ–‡</span>
                <br><br>
                é¢„æµ‹"<span class="highlight">${targetChar}</span>"æ—¶ï¼Œæ¨¡å‹ä¼š"çœ‹"å‰é¢æ‰€æœ‰å­—ç¬¦ã€‚
                <br><br>
                <span class="highlight-orange">ç´«è‰²è¿çº¿</span>è¡¨ç¤ºæ³¨æ„åŠ›æƒé‡ï¼š<br>
                â€¢ çº¿è¶Šäº® = å…³æ³¨åº¦è¶Šé«˜<br>
                â€¢ æ¨¡å‹å­¦ä¼šäº†å“ªäº›å­—æ›´é‡è¦
                <br><br>
                ğŸ’¡ ${data.insight}
            `;

            // åˆ›å»ºæŸ¥è¯¢ç‚¹ï¼ˆé¢„æµ‹ä½ç½®ï¼‰
            const targetData = embedPositions[targetChar];
            const queryPos = targetData.pos.clone();
            queryPos.y += 2; // åœ¨ç›®æ ‡ä½ç½®ä¸Šæ–¹

            queryMesh = createCharSphere('?', queryPos, 0xFF3B30, 0.8);
            queryMesh.originalY = queryPos.y;

            await sleep(500);

            // ç»˜åˆ¶æ³¨æ„åŠ›è¿çº¿
            for (const [char, weight] of Object.entries(data.attention)) {
                if (charMeshes[char]) {
                    const fromPos = charMeshes[char].group.position.clone();
                    const lineObj = createCurvedAttentionLine(fromPos, queryPos, weight);
                    attentionLines.push(lineObj);
                    animationObjects.push(lineObj);
                    await sleep(150);
                }
            }

            await sleep(1500);
        }

        // Step 3: è¾“å‡ºå±‚
        async function showOutputStep(targetChar) {
            const data = predictionData[targetChar];

            document.getElementById('panelTitleText').textContent = 'âœ¨ è¾“å‡ºå±‚ (Prediction)';
            document.getElementById('explanationText').innerHTML = `
                <span class="highlight">ç¬¬ä¸‰æ­¥ï¼šè®¡ç®—æ¦‚ç‡ï¼Œé€‰æ‹©ä¸‹ä¸€ä¸ªå­—</span>
                <br><br>
                Transformerè¾“å‡ºä¸€ä¸ªå‘é‡ï¼Œä¸æ‰€æœ‰å€™é€‰å­—çš„å‘é‡<span class="highlight-orange">è®¡ç®—ç›¸ä¼¼åº¦</span>ã€‚
                <br><br>
                é€šè¿‡<span class="highlight-blue">Softmax</span>è½¬æ¢ä¸ºæ¦‚ç‡åˆ†å¸ƒï¼š
                <div class="formula-box">
                    P(å­—) = e^(ç›¸ä¼¼åº¦) / Î£e^(æ‰€æœ‰ç›¸ä¼¼åº¦)
                </div>
                æ¦‚ç‡æœ€é«˜çš„å­—è¢«é€‰ä¸­ï¼
            `;

            // æ˜¾ç¤ºå€™é€‰é¢æ¿
            document.getElementById('candidatesPanel').style.display = 'block';
            const listEl = document.getElementById('candidatesList');
            listEl.innerHTML = '';

            // åˆ›å»ºå€™é€‰çƒä½“å’Œåˆ—è¡¨
            for (let i = 0; i < data.candidates.length; i++) {
                const cand = data.candidates[i];

                await sleep(200);

                // 3Dçƒä½“
                const color = i === 0 ? 0x34C759 : 0xFF9500;
                const mesh = createCharSphere(cand.char, cand.vec, color, 0.7);
                mesh.originalY = cand.vec.y;
                candidateMeshes.push(mesh);

                // åˆ°æŸ¥è¯¢ç‚¹çš„è¿çº¿
                if (queryMesh) {
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([
                        queryMesh.group.position.clone(),
                        cand.vec
                    ]);
                    const lineMat = new THREE.LineDashedMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.5,
                        dashSize: 0.2,
                        gapSize: 0.1
                    });
                    const line = new THREE.Line(lineGeom, lineMat);
                    line.computeLineDistances();
                    scene.add(line);
                    attentionLines.push({ line });
                }

                // UIåˆ—è¡¨
                const item = document.createElement('div');
                item.className = 'candidate-item' + (i === 0 ? ' winner' : '');
                item.innerHTML = `
                    <div class="candidate-char ${i === 0 ? 'winner' : ''}">${cand.char}</div>
                    <div class="candidate-info">
                        <div class="candidate-prob" style="color: ${i === 0 ? '#34C759' : '#FF9500'}">
                            ${(cand.prob * 100).toFixed(0)}%
                        </div>
                        <div class="candidate-dist">${i === 0 ? 'âœ“ é€‰ä¸­' : 'å€™é€‰'}</div>
                    </div>
                `;
                listEl.appendChild(item);
            }

            await sleep(1500);

            return data.candidates[0].char;
        }

        function clearAttentionAndCandidates() {
            // æ¸…é™¤æ³¨æ„åŠ›çº¿
            attentionLines.forEach(obj => {
                if (obj.line) scene.remove(obj.line);
                if (obj.particle) scene.remove(obj.particle);
            });
            attentionLines = [];
            animationObjects = [];

            // æ¸…é™¤å€™é€‰çƒä½“
            candidateMeshes.forEach(mesh => {
                if (mesh && mesh.group) scene.remove(mesh.group);
            });
            candidateMeshes = [];

            // æ¸…é™¤æŸ¥è¯¢çƒ
            if (queryMesh) {
                scene.remove(queryMesh.group);
                queryMesh = null;
            }

            document.getElementById('candidatesPanel').style.display = 'none';
        }

        // åˆå§‹åŒ–
        init();
    </script>
</body>
</html>
